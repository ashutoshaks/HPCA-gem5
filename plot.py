# Configs generated by the following choices
# LQEntries: 32, 64
# • SQEntries: 32, 64
# • l1d size: 32kB, 64kB
# • l1i size: 8kB, 16kB
# • l2 size: 256kB, 512kB
# • bp type: TournamentBP, BiModeBP
# • ROBEntries: 128, 192
# • numIQEntries: 16, 64



# Metrics to be plotted for top 10 cpi configs
# – Cycles Per Instruction (CPI). system.cpu.cpi
# – Mispredicted branches detected during execution.
# – Number of branches that were predicted not taken incorrectly.
# – Number of branches that were predicted taken incorrectly.
# – Instructions Per Cycle (IPC).
# – Number of BTB hit percentage.

# – Number of overall miss cycles - 3, miss rate - 3, average overall miss latency - 3.

# – The number of ROB accesses (read and write both) - 2
# – Number of times the LSQ has become full, causing a stall.
# – Number of loads that had data forwarded from stores.
# – Number of times access to memory failed due to the cache being blocked.


#  Total fields to capture  = 20

import matplotlib.pyplot as plt
import matplotlib.ticker as mticker
import re
import os
import argparse
import seaborn as sns
from tqdm import tqdm
import sys

SAMPLE_DIRECTORY_NAME = '32-32-32kB-8kB-256kB-TournamentBP-128-16'

FILE_NAME = 'stats.txt'
PLOT_DIR = 'plots'
parser = argparse.ArgumentParser()

parser.add_argument("-d", help="Folder containing stats for different configurations", required=True)
dir_path = vars(parser.parse_args())['d']
PARAMS_TO_RECORD = {
    'system.cpu.cpi' : 'CPI',
    'system.cpu.commit.branchMispredicts' : 'BranchMisPred',
    'system.cpu.iew.predictedNotTakenIncorrect' : 'PredNotTakenIncorrect',
    'system.cpu.iew.predictedTakenIncorrect' : 'PredTakenIncorrect',
    'system.cpu.ipc' : 'IPC',
    'system.cpu.branchPred.BTBHitRatio': 'BTBHitFraction', # need to print in % format

    'system.cpu.dcache.overallMisses::total': 'MissCycleDcache',
    'system.cpu.icache.overallMisses::total': 'MissCycleIcache',
    'system.l2cache.overallMisses::total': 'MissCycleL2cache',

    'system.cpu.dcache.overallMissRate::total': 'MissRateDcache',
    'system.cpu.icache.overallMissRate::total': 'MissRateIcache',
    'system.l2cache.overallMissRate::total': 'MissRateL2cache',

    'system.cpu.dcache.overallAvgMissLatency::total': 'OverallAvgMissLatDcache',
    'system.cpu.icache.overallAvgMissLatency::total': 'OverallAvgMissLatIcache',
    'system.l2cache.overallAvgMissLatency::total': 'OverallAvgMissLatL2cache',    

    'system.cpu.rob.reads' : 'ReadRob',
    'system.cpu.rob.writes' : 'WriteRob',

    'system.cpu.iew.lsqFullEvents' : 'StallDueToLSQFull',
    'system.cpu.lsq0.forwLoads' : 'StoreLoadFwd',
    'system.cpu.lsq0.blockedByCache' : 'MemFailedBlockedByCache',
}

INT_PARAMS = set([
    'system.cpu.commit.branchMispredicts',
    'system.cpu.iew.predictedNotTakenIncorrect',
    'system.cpu.iew.predictedTakenIncorrect',
    'system.cpu.dcache.overallMisses::total',
    'system.cpu.icache.overallMisses::total',
    'system.l2cache.overallMisses::total',
    'system.cpu.rob.reads',
    'system.cpu.rob.writes',
    'system.cpu.iew.lsqFullEvents',
    'system.cpu.lsq0.forwLoads',
    'system.cpu.lsq0.blockedByCache',])

OUTPUT_FIELDS = [PARAMS_TO_RECORD[k] for k in PARAMS_TO_RECORD]
assert(len(OUTPUT_FIELDS) == 20)

def extractDataForConfig(config_directory:str) -> dict:
    # dir_name = '-'.join(config)
    lines = None
    # print(dir_path,config_directory, FILE_NAME)
    file_addr = dir_path + '/' + config_directory + '/' + FILE_NAME
    with open(file_addr, 'r') as f:
        lines = [line for line in f]
    
    data = dict()
    for line in lines:
        fields = re.sub('\s+',' ',line)
        fields = fields.split(" ")
        if fields[0] in PARAMS_TO_RECORD.keys():
            if fields[0] in INT_PARAMS:
                data[PARAMS_TO_RECORD[fields[0]]] = int(fields[1])
            else:
                data[PARAMS_TO_RECORD[fields[0]]] = float(fields[1])
    # import ipdb
    # ipdb.set_trace()
    for f in OUTPUT_FIELDS:
        if f not in data:
            print(f'{f} is not present in the file for config {config_directory}')
    assert(len(data) == len(OUTPUT_FIELDS))
    
    return data





if __name__ == '__main__':

    # Run command
    # python plot.py -d results
    if not os.path.exists(PLOT_DIR):
        os.makedirs(PLOT_DIR)

    all_data = {}

    print("Processing data for all the configurations", file = sys.stderr)
    for subdir in tqdm(os.listdir(dir_path)):
        if os.path.isdir(dir_path + "/" + subdir):
            all_data[subdir] = extractDataForConfig(subdir)

    CPIs = [(all_data[cnfg]['CPI'], cnfg) for cnfg in all_data.keys()]
    CPIs.sort(key=lambda x:x[0])
    CPITop10 = CPIs[:10]
    Top10Configs = [cnfg[1] for cnfg in CPITop10]
    toPrint = [cnfg[1] +" - "+str(cnfg[0]) for cnfg in CPITop10]
    print('The top 10 configurations w.r.t CPI values are')
    print('\n'.join(toPrint))

    # sort and choose top 10
    num_of_data_points = min(10, len(Top10Configs))
    x_data = list(range(1, num_of_data_points + 1))

    print("Plotting different metrics of the top 10 configurations", file = sys.stderr)
    plt.rcParams.update({'font.size': 15})
    for key in tqdm(OUTPUT_FIELDS):
        sns.set_style("darkgrid", {"grid.color": ".4", "grid.linestyle": ":"})
        plt.figure(figsize= (19, 8))

        plt.ticklabel_format(style='plain')

        ax = plt.gca()
        # ax.yaxis.offsetText.set_visible(True)
        # offset = ax.yaxis.get_major_formatter().get_offset()

        ax.ticklabel_format(style='plain', axis='y')

        # y_formatter = mticker.ScalarFormatter(useOffset=False)
        # ax.yaxis.set_major_formatter(y_formatter)

        y_data = [all_data[cnfg][key] for cnfg in Top10Configs]
        data_variations =  max(y_data) - min(y_data)
        max_y_lim = .15*data_variations + max(y_data)
        min_y_lim = -.5*data_variations + min(y_data)
        plt.ylim(min_y_lim, max_y_lim)
        plt.bar(x_data, y_data)
        for index, data in enumerate(y_data):
            plt.text(index + .5, data + 0.01*data_variations, '{0:10}'.format(data))
        plt.xlabel("configs")
        plt.ylabel(key)
        plt.xticks(x_data)
        plt.title(key + f" for top {num_of_data_points} configs by CPI")
        plt.savefig(f'{PLOT_DIR}/' + key + ".png", bbox_inches='tight')

    # plots in respective folders
    print(f"You can find the plots in the following directory :{PLOT_DIR}", file = sys.stderr)